<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Burning Ashes</title>
    <link>https://daseinphaos.github.io/index.xml</link>
    <description>Recent content on Burning Ashes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Jul 2018 21:37:27 +0800</lastBuildDate>
    <atom:link href="https://daseinphaos.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>BECK</title>
      <link>https://daseinphaos.github.io/post/beck/</link>
      <pubDate>Thu, 12 Jul 2018 21:37:27 +0800</pubDate>
      
      <guid>https://daseinphaos.github.io/post/beck/</guid>
      <description>&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=&#34;320&#34; height=86 src=&#34;//music.163.com/outchain/player?type=2&amp;id=22793552&amp;auto=0&amp;height=66&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;有这么一些动画，看过之后，会让我产生纠结。&lt;/p&gt;

&lt;p&gt;一方面是饱餐美食的心满意足，另外一方面则是一种更深的饥饿。一种懊恼。&lt;/p&gt;

&lt;p&gt;懊恼自己年轻的时候错过了它。如果是年轻的时候，看到它，我会是什么心情呢。我的人生轨迹又会发生什么变化呢。&lt;/p&gt;

&lt;p&gt;我不知道。一时间也难以想象。&lt;/p&gt;

&lt;p&gt;听一首歌吧，闷一口酒吧，唱出声来吧。&lt;/p&gt;

&lt;p&gt;讴歌青春！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一部童话</title>
      <link>https://daseinphaos.github.io/post/meidoragunn/</link>
      <pubDate>Sat, 08 Apr 2017 19:34:18 +0000</pubDate>
      
      <guid>https://daseinphaos.github.io/post/meidoragunn/</guid>
      <description>&lt;p&gt;现实世界很操蛋的，冲突——个人的到集体的，无伤大雅的到惨绝人寰的——一直都在发生。更加糟糕的是，对于其中的某些冲突，即便聚集了人类社会里的尖端人才，采用了人类智慧的最新结晶；都不一定能够得到解决。而我们每一个个体，仅作为一个个无能的凡人，只有承受一条路可走。&lt;/p&gt;

&lt;p&gt;这就是为什么我们需要童话——一种“通过丰富的想象、幻想和夸张来编写适合于儿童欣赏的故事”&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;的文学体裁。&lt;/p&gt;

&lt;p&gt;对于某些问题，多数普通人所具备的认知，并不比一般意义上的儿童认知更加丰富。对于这些问题，我们需要童话。在架空的幻想里去谈论它们，相比于基于现实生活的论述——往往已被问题精英们进行至焦头烂额却仍无建树；无论对于作者还是读者来说，都是一件更加舒适、更易实施的行动。&lt;/p&gt;

&lt;p&gt;批评家大可认为此类作品避重就轻，毫无“意义”。从某种角度来说，他们没错。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;但童话之所以被称为童话——而非什么“最佳指南”——其原因也正在于此：它们并不声称自己要去阐述或解决实际问题，而是就这些问题给“儿童”们提供一点引导材料，和一点希望，仅此而已。&lt;/p&gt;

&lt;p&gt;龙女仆就是这样的一部童话。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;《现代汉语词典（第6版）》，2012，商务印书馆
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;批评家们也可以批评说,&lt;em&gt;一切&lt;/em&gt; 声明从 &lt;em&gt;某种&lt;/em&gt; 角度来说都是对的。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://daseinphaos.github.io/about/</link>
      <pubDate>Wed, 01 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daseinphaos.github.io/about/</guid>
      <description>&lt;p&gt;C++/Rust developer.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Closure, Lifetime, and HRT</title>
      <link>https://daseinphaos.github.io/post/closure-lifetime-hrt/</link>
      <pubDate>Wed, 01 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daseinphaos.github.io/post/closure-lifetime-hrt/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;So here is the thing. Can we write something like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut vector = vec![1, 2, 3];
let mut closure = |x| vector.get_mut(x);
println!(&amp;quot;{:?}&amp;quot;, closure(2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in Rust?&lt;/p&gt;

&lt;p&gt;The answer is, unfortunately, no.&lt;/p&gt;

&lt;p&gt;Compiling it as of &lt;code&gt;rust 1.15.1&lt;/code&gt; would yield some error message like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error[E0495]: cannot infer an appropriate lifetime for lifetime parameter in function call due to conflicting requirements
   --&amp;gt; src\main.rs:100:23
    |
100 |     let closure = |x| vector.get_mut(x);
    |                       ^^^^^^
    |
note: first, the lifetime cannot outlive the lifetime  as defined on the body at 100:22...
   --&amp;gt; src\main.rs:100:23
    |
100 |     let closure = |x| vector.get_mut(x);
    |                       ^^^^^^^^^^^^^^^^^
note: ...so that closure can access `vector`
   --&amp;gt; src\main.rs:100:23
    |
100 |     let closure = |x| vector.get_mut(x);
    |                       ^^^^^^
note: but, the lifetime must be valid for the scope of call-site for function at 100:22...
   --&amp;gt; src\main.rs:100:23
    |
100 |     let closure = |x| vector.get_mut(x);
    |                       ^^^^^^^^^^^^^^^^^
note: ...so that return value is valid for the call
   --&amp;gt; src\main.rs:100:19
    |
100 |     let closure = |x| vector.get_mut(x);
    |                   ^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One got to admit that such an error message is nowhere near helpful. So let&amp;rsquo;s try to figure out what&amp;rsquo;s &lt;em&gt;really&lt;/em&gt; going on here on our own.&lt;/p&gt;

&lt;p&gt;Back to the original closure. The intention was quiet simple: we wanted the closure to capture the &lt;code&gt;vector&lt;/code&gt; in its environment. Upon subsequent invocations to the closure, a mutable reference to an element of the captured &lt;code&gt;vector&lt;/code&gt; would be returned. Nothing fancy, just a tiny bit of a wrapper of the &lt;code&gt;get_mut&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;However, to our surprise, such a tiny code snippet failed the borrow checker, leaving us some mysterious error message.&lt;/p&gt;

&lt;p&gt;To solve the mystery, let&amp;rsquo;s try to implement such a closure struct by hand - closure by itself is already mysterious enough, maybe we can figure this out if we get that mess cleared out of the picture.&lt;/p&gt;

&lt;p&gt;So, a trip into manually implementing closures&amp;hellip;&lt;/p&gt;

&lt;p&gt;First thing first, let&amp;rsquo;s try to define how our &lt;code&gt;Closure&lt;/code&gt; would layout.&lt;/p&gt;

&lt;p&gt;As a simple glimpse, we&amp;rsquo;d like the closure to be able to return a mutable reference into its captured &lt;code&gt;vector&lt;/code&gt;. As such, at the minimum, the &lt;code&gt;Closure&lt;/code&gt; struct should also take such a mutable reference:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Closure&amp;lt;&#39;a&amp;gt; {
    inner: &amp;amp;&#39;a mut Vec&amp;lt;i32&amp;gt;, // Assuming `i32` for simplicity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let&amp;rsquo;s try adding function-like behavior for our struct. To achieve this we would have to implement &lt;code&gt;FnMut&lt;/code&gt;: we wanted the closure to be reusable (once the last returned borrow gets out of scope), thus it can&amp;rsquo;t simply be an one-off shot. However, due to the current definition of the &lt;code&gt;Fn&lt;/code&gt;-series of traits, implementing &lt;code&gt;FnMut&lt;/code&gt; would also require the &lt;code&gt;FnOnce&lt;/code&gt; trait to be implemented. Also, we have to pack the input parameters into a tuple ( even if under our cases there is only one input parameter). Anyway, let&amp;rsquo;s just get the &lt;code&gt;FnOnce&lt;/code&gt; done first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Requeried as custom-implementing `Fn`s is unstable for now
#![feature(unboxed_closures)]
#![feature(fn_traits)]

// struct definition here...

impl&amp;lt;&#39;a&amp;gt; FnOnce&amp;lt;(usize,)&amp;gt; for Closure&amp;lt;&#39;a&amp;gt; {
    // directy returning reference rather than `Option` for simplicity
    type Output = &amp;amp;&#39;a mut i32;

    extern &amp;quot;rust-call&amp;quot; 
    fn call_once(self, (i,): (usize, )) -&amp;gt; &amp;amp;&#39;a mut i32 {
        self.inner.get_mut(i).unwrap()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, so good. Now let&amp;rsquo;s try to implement &lt;code&gt;FnMut&lt;/code&gt; as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...

impl&amp;lt;&#39;a&amp;gt; FnMut&amp;lt;(usize,)&amp;gt; for Closure&amp;lt;&#39;a&amp;gt; {
    extern &amp;quot;rust-call&amp;quot;
    fn call_mut(&amp;amp;mut self, (i,): (usize, )) -&amp;gt; &amp;amp;&#39;a mut i32 {
        self.inner.get_mut(i).unwrap()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Boom! Now here is that error once again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error[E0495]: cannot infer an appropriate lifetime for lifetime parameter in function call due to conflicting requirements
   --&amp;gt; src\main.rs:120:9
    |
120 |         self.inner.get_mut(i).unwrap()
    |         ^^^^^^^^^^
    |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the body at 119:59...
   --&amp;gt; src\main.rs:119:60
    |
119 |       fn call_mut(&amp;amp;mut self, (i,): (usize, )) -&amp;gt; &amp;amp;&#39;a mut i32 {
    |  ____________________________________________________________^ starting here...
120 | |         self.inner.get_mut(i).unwrap()
121 | |     }
    | |_____^ ...ending here
note: ...so that reference does not outlive borrowed content
   --&amp;gt; src\main.rs:120:9
    |
120 |         self.inner.get_mut(i).unwrap()
    |         ^^^^^^^^^^
note: but, the lifetime must be valid for the lifetime &#39;a as defined on the body at 119:59...
   --&amp;gt; src\main.rs:119:60
    |
119 |       fn call_mut(&amp;amp;mut self, (i,): (usize, )) -&amp;gt; &amp;amp;&#39;a mut i32 {
    |  ____________________________________________________________^ starting here...
120 | |         self.inner.get_mut(i).unwrap()
121 | |     }
    | |_____^ ...ending here
note: ...so that reference does not outlive borrowed content
   --&amp;gt; src\main.rs:120:9
    |
120 |         self.inner.get_mut(i).unwrap()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although this time, one might reasonably argue that the error message is indeed helpful.&lt;/p&gt;

&lt;p&gt;It turns out that, returning &lt;code&gt;&amp;amp;&#39;a mut i32&lt;/code&gt; is not feasible for the shorter-live invocation of &lt;code&gt;call_mut&lt;/code&gt;. What we&amp;rsquo;ve really wanted for the return type of &lt;code&gt;call_mut&lt;/code&gt;, was something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...

impl&amp;lt;&#39;a&amp;gt; FnMut&amp;lt;(usize,)&amp;gt; for Closure&amp;lt;&#39;a&amp;gt; {
    extern &amp;quot;rust-call&amp;quot;
    fn&amp;lt;&#39;b&amp;gt; call_mut(&amp;amp;&#39;b mut self, (i,): (usize, )) -&amp;gt; &amp;amp;&#39;b mut i32 {
        self.inner.get_mut(i).unwrap()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, we want the returned reference to live only as long as the invocation scope of &lt;code&gt;call_mut&lt;/code&gt; ( i.e. &lt;code&gt;&#39;b&lt;/code&gt;), nothing more. Certainly not the entire scope of the &lt;code&gt;Closure&lt;/code&gt; ( i.e. &lt;code&gt;&#39;a&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Now clearly the code above won&amp;rsquo;t compile either.&lt;/p&gt;

&lt;p&gt;For one thing, we can&amp;rsquo;t &amp;ldquo;generically&amp;rdquo; implement a trait method across what it&amp;rsquo;d otherwise not; for the other, even if we can, to maintain the subtype-invariance of &lt;code&gt;type Output&lt;/code&gt; (note that &lt;code&gt;FnOnce&lt;/code&gt; and &lt;code&gt;FnMut&lt;/code&gt; shares the same output type, which I think is fairly reasonable), &lt;code&gt;&#39;b&lt;/code&gt; would &lt;em&gt;have&lt;/em&gt; to a subtype of &lt;code&gt;&#39;a&lt;/code&gt; (i.e. it have to outlive &lt;code&gt;&#39;a&lt;/code&gt;, or at least live as long), which makes the method totally useless for us.&lt;/p&gt;

&lt;p&gt;So is there anyway that we can actually solve this?&lt;/p&gt;

&lt;p&gt;Intuitively, one might think that generics can help us out here. If we could make a generic &lt;code&gt;impl&lt;/code&gt; of &lt;code&gt;FnMut&lt;/code&gt; (thus &lt;code&gt;FnOnce&lt;/code&gt; as well) over all possible lifetimes &lt;code&gt;&#39;b&lt;/code&gt;&amp;hellip; Ok, that&amp;rsquo;s apparently impossible either, as &lt;code&gt;type Output&lt;/code&gt; is an associate type rather than an input type.&lt;/p&gt;

&lt;p&gt;For me, I see only one way out, that is, the introducing of higher ranked types (HRT).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;more to come&amp;hellip;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>